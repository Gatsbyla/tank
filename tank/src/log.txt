这个只用来学dp分支以及做笔记
m V 分离model就是我们的数据，我们的实体tank bullet，它不再跟view打交道了，也就是tankframe
控制model怎么显示，以及model传过来的数据怎么处理，这个还需要加另外一个，controller
在tank里把持有的tf去掉了， 一概不用了，因为它不再和前面的显示打交道了，这样我们model自己发展的时候也会比较
方便，添加model也会更方便，前端的显示也会更方便，你只需要把gamemodel传给我，我二话不说把它画出来，至于
你内部怎么处理怎么画的和我没关系

门面中的建立关系其实 是说持有引用，你把所有持有的 引用抽到一个类里面也就是门面里面，那么其他frame要访问的时候
只需要持有门面的引用就行了而不需要每个都持有那些坦克、子弹、爆炸。。。的引用,以后你窗口的变化对我model没影响
窗口可以有窗口的风格，model也可以有model的变化，所有的对象不再frame里面new了，而是frame持有一个(1个)
gamemodel的引用，多到一所有你怎么变化都不会影响model因为model在frame里变成原子了，这样model
和view就做到了分离

你后端的分层不也是这样吗，service持有一个dao的引用,controller持有service的引用

tankframe里把所有 的model单独抽出来一层facade实现了model和view的分离

调停者 把许多for循环变成一个for循环，你原来碰撞添加一个新物体比如墙你就需要增加多少个for循环，你想想，少了
还好说，那些画出来的联系不就是  传参作为参数或者作为持有引用吗，别觉得两个方块之间就画了一条线，对应为对象，那就是每一对
对象都有一个联系比如物体.collide(另一个物体),要用for循环的

持有引用或作为参数！！！


把责任链到一起就成了责任链了，既然能链到一起那么肯定实现了相同的接口或者继承了相同的父类

聚合关系has a 拥有持有

一个设计原则，高内聚，低耦合，属于我的责任都放在我这，不属于我的责任我尽量不参与

什么是耦合呢，就是说我要改这个类，另一个类有可能会变。
耦合的级别，最高的是继承，然后是聚合，第三A类在b类的方法里面，方法的参数或者方法的返回值，这个时候关联
降低耦合可以从这几个方面考虑
一般的情况，一定不要多加属性，属性够了就行，越加就越复杂


装饰模式
聚合代替继承，因为继承不灵活，你要加多个装饰怎么办呢。但这种方式仍然不够好，我想让这个加到子弹上怎么办呢？所以
你持有的引用应该是GameModel

装饰模式，你装饰完了还是GameModel所以要继承自GameModel,因为你要装饰，就要持有你要装饰的目标的引用
持有了对象的引用你还不想干啥干啥

很多模式并不是在语法上区别而是在语义上区别，比如装饰器和桥梁模式